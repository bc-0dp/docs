# Caching best practices

BigCommerce supports multiple frameworks that you can use to build your storefront - Stencil, Next.js Commerce, and Catalyst.

The following sections describe 
-  General recommendations that apply to all three frameworks.
-  How the usage and capabilities for each framework give rise to distinct caching best practices.

**Summary of differences and capabilities**

| Feature or aspect	| Stencil | Next.js Commerce | Catalyst |
| :-- | :-- | :-- | :-- |
| Primary framework	| BigCommerce's native framework | Next.js	| Headless (supports various frameworks) |
| Usage scenario | Pre-built themes, quick setup for BigCommerce stores	| Pre-configured e-commerce sites with Next.js	| Custom e-commerce solutions with various front-end technologies |
| Core capabilities	| Theme-specific caching, server-side rendering	| SSG, ISR, built-in image optimization	| API-first, flexible front-end integration |
| Caching best practices | Optimize theme assets, partial caching | Leverages SSG and ISR, API response caching	| API response caching, client-side storage, service workers |


## General recommendations 

We recommend the following best practices for Stencil, Next.js Commerce, and Catalyst:

1. Minify and compress static assets: reduce file size and improve loading times for CSS and JavaScript files.

2. Use `Cache-Control` headers instruct browsers and CDNs how long files for static assets should be cached.

3. Cache frequently accessed data from API responses, for example, product listings and user information. 

Each framework uses versioned filenames so browsers fetch the latest versions of a static asset, automating the cache invalidation process. 
The build process automatically generates versioned filenames and updates references in the HTML or other assets.


## Stencil 

Stencil is tightly integrated with BigCommerceâ€™s platform and focuses on optimizing the delivery of theme assets.

Stencil comes with built-in caching mechanisms that don't require extensive configuration from you:

- Theme-Specific caching: Integrates caching for assets, templates, partials, CSS, and JavaScript into the theme development process.

- Server-Side rendering: Emphasizes server-side rendering to pre-render pages and cache them for quick delivery.

Best Practices:

- Optimize Theme Assets: Focus on optimizing and caching CSS, JavaScript files, images, and fonts used in themes. 

Stencil uses Webpack to bundle and manage assets. Configure Webpack (typically found in `webpack.config.js` or similar) to include settings for `Cache-Control` headers and plugins for minifying and compressing static assets.
Execute the Stencil build command (`stencil build`) to compile your theme and apply the configured optimizations.

- Partial Caching: Cache reusable components (partials) to reduce redundant server-side processing.

BigCommerce configures and manages Varnish Cache to handle caching at the edge. This includes setting up Edge-Side Includes (ESI), which allows you to independently cache fragments of a page.
While you can't directly configure Varnish Cache or ESI, you can structure your theme and templates to be cache-friendly:

1. Create and use partial templates, smaller, reusable pieces of HTML or template code that can be included in multiple places within a theme. Caching partials is primarily intended for static parts of the page, such as headers and footers.

2. You can also structure your templates to use ESI for parts of the page that change less frequently.


### Next.js Commerce

Directly built on Next.js, Next.js Commerce inherently leverages Next.js-specific features.

The framework's core capabilities for caching include the following:

- [Static Site Generation (SSG)](https://nextjs.org/docs/pages/building-your-application/rendering/static-site-generation): Uses SSG to pre-render pages at build time, serving them as static files for fast delivery.
- [Incremental Static Regeneration (ISR)](https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration): Allows static pages to be updated in the background, keeping content fresh without full rebuilds.
- [Image Optimization](https://nextjs.org/docs/pages/building-your-application/optimizing/images): Uses the Next.js Image component for automatic image optimization.

Best Practices:

- Leverage SSG and ISR: Utilize SSG and ISR for pre-rendering and updating static content, ensuring optimal performance and content freshness.
- API Response Caching: Cache responses from APIs used by the application.

### Catalyst

Catalyst is designed as a headless commerce solution for custom e-commerce experiences.

The following headless architecture leads to unique caching best practices:

- Front-end flexibility: Designed to integrate with various front-end technologies, where developers can use modern front-end frameworks and leverage their caching capabilities.
- API-first approach: Focuses on providing a robust API layer for data fetching and manipulation.

Best Practices:

- Advanced API Caching: Focus on caching API responses, particularly for frequently accessed data like product listings, inventory, and pricing.
- Service Worker Utilization: Extensively use service workers for pre-caching and dynamic caching of API responses.
- Client-Side Storage: Use client-side storage solutions to cache data locally, reducing the need for repeated API calls.