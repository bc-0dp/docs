# Caching best practices

BigCommerce supports multiple frameworks that you can use to build your storefront - Stencil, Next.js Commerce, and Catalyst.

The following sections describe 
-  General recommendations that apply to all three frameworks.
-  How the usage and capabilities for each framework give rise to distinct caching best practices.

**Summary of differences and capabilities**

| Feature or aspect	| Stencil | Next.js Commerce | Catalyst |
| :-- | :-- | :-- | :-- |
| Primary framework	| BigCommerce's native framework | Next.js	| Headless (supports various frameworks) |
| Usage scenario | Pre-built themes, quick setup for BigCommerce stores	| Pre-configured e-commerce sites with Next.js	| Custom e-commerce solutions with various front-end technologies |
| Core capabilities	| Theme-specific caching, server-side rendering	| SSG, ISR, built-in image optimization	| API-first, flexible front-end integration |
| Caching best practices | Optimize theme assets, partial caching | Leverages SSG and ISR, API response caching	| API response caching, client-side storage, service workers |


## General recommendations 

We recommend the following best practices for Stencil, Next.js Commerce, and Catalyst:

1. Minify and compress static assets: reduce file size and improve loading times for CSS and JavaScript files.

2. Use `Cache-Control` headers instruct browsers and CDNs how long files for static assets should be cached.

3. Cache frequently accessed data from API responses, for example, product listings and user information. 

Each framework uses versioned filenames so browsers fetch the latest versions of a static asset, automating the cache invalidation process. 
The build process automatically generates versioned filenames and updates references in the HTML or other assets.


## Stencil 

Focus and integration:

- Theme-Specific Caching: Stencil is tightly integrated with BigCommerceâ€™s platform, with built-in caching mechanisms tailored for theme assets, templates, and partials.
- Server-Side Rendering: Emphasizes server-side rendering to pre-render pages and cache them for quick delivery.

Best Practices:

- Optimize Theme Assets: Focus on optimizing and caching CSS, JavaScript files, images, and fonts used in themes. 

Stencil uses Webpack to bundle and manage assets. Configure Webpack (typically found in `webpack.config.js` or similar) to include settings for `Cache-Control` headers and plugins for minifying and compressing static assets.
Execute the Stencil build command (`stencil build`) to compile your theme and apply the configured optimizations.

- Partial Caching: Cache reusable components (partials) to reduce redundant server-side processing.



### Next.js Commerce

Framework Capabilities:

- Static Site Generation (SSG): Uses SSG to pre-render pages at build time, serving them as static files for fast delivery.
- Incremental Static Regeneration (ISR): Allows static pages to be updated in the background, keeping content fresh without full rebuilds.
- Next.js Image Optimization: Uses the Next.js Image component for automatic image optimization.

Best Practices:

- Leverage SSG and ISR: Utilize SSG and ISR for pre-rendering and updating static content, ensuring optimal performance and content freshness.
- API Response Caching: Cache responses from APIs used by the application.

### Catalyst

Headless Architecture:

- Flexibility: Designed to integrate with various front-end technologies, offering greater flexibility in building custom e-commerce experiences.
- Advanced API Caching: Focuses on caching API responses, particularly for frequently accessed data like product listings, inventory, and pricing.

Best Practices:

- Advanced API Caching: Implement caching strategies for API responses to reduce server load and improve latency.
- Service Worker Utilization: Extensively use service workers for pre-caching and dynamic caching of API responses.
- Client-Side Storage: Utilize client-side storage solutions to cache data locally, reducing the need for repeated API calls.